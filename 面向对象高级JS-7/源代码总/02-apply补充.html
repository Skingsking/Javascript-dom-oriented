<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>

        var obj = {
            0:"abc",
            1:"def",
            2:"hig",
            length:3
        }
//错误的代码
//        var arr = [].concat(1,2,3,4,5);
//        console.log(arr)；

        //正确的代码
        var arr = [].concat.apply([],obj);
        //[].concat(obj[0],obj[1],obj[2])
        console.log(arr);  // abc  def  hig

        function test() {
//            console.log(this.valueOf());
//            console.log(+this);
            console.log(""+this);
        }
        test.apply(1);
        test.call("abc");   //apply  和call  传入一个值的话都是 一样的


        test.call(true)
        test.apply(undefined) // object window

        //当时用call和apply传入的第一个参数为值类型的时候
        //会将值类型转换成对应的对象（引用类型） 然后赋值给this

        //当传入的第一个参数为 null或者Undefined的时候，
        //会把this赋值为  window

        //借用构造函数 实现继承
        function Person(){
            this.name = "张莎";
            this.age = 18;
        }

        function Student(){
            // 改变了this的指向
            var stu = this;
            // apply 指向的是 new 出来的对象
            Person.apply(stu);
        }

        var stu = new Student();
        console.log(stu);  //student  指向的为他new出来的对象吗



        function Miss(name){
            this.name=name;
        }
        var b=new Miss('你好');
        console.log(b);


    </script>

</head>
<body>

</body>
</html>